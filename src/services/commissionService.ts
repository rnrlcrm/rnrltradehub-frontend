/**
 * Commission Service
 * Handles commission calculation, invoice generation, and payment tracking
 * Includes sub-broker commission sharing
 */

export interface CommissionConfig {
  type: 'PERCENTAGE' | 'PER_BALE' | 'FLAT';
  value: number;
  gstApplicable: boolean;
  gstRate: number; // 18% for brokerage services (SAC 9983)
  sacCode: string; // '9983' for brokerage/commission
  paymentTermDays: number; // Default 30 days
}

export interface CommissionInvoice {
  id: string;
  invoiceNumber: string;
  invoiceDate: string;
  dueDate: string;
  
  // Contract details
  contractId: string;
  contractNo: string;
  contractDate: string;
  contractValue: number;
  commodity: string;
  quantity: number;
  
  // Broker details
  brokerId: string;
  brokerName: string;
  brokerGSTIN?: string;
  brokerEmail: string;
  
  // Commission details
  commissionType: 'buyer' | 'seller';
  commissionConfig: CommissionConfig;
  commissionAmount: number;
  gstAmount: number;
  totalAmount: number;
  
  // Sub-broker (if applicable)
  hasSubBroker: boolean;
  subBrokerId?: string;
  subBrokerName?: string;
  subBrokerEmail?: string;
  commissionSharePercent?: number; // % shared with sub-broker
  subBrokerAmount?: number;
  mainBrokerAmount?: number;
  
  // Payment tracking
  status: 'Draft' | 'Sent' | 'Overdue' | 'Paid' | 'Partially_Paid';
  sentDate?: string;
  paidAmount: number;
  outstandingAmount: number;
  paymentDate?: string;
  
  // Reminders
  remindersSent: number;
  lastReminderDate?: string;
  nextReminderDate?: string;
  
  // Automation
  autoGenerated: boolean;
  emailSent: boolean;
  
  // Audit
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface CommissionPayment {
  id: string;
  paymentId: string;
  commissionInvoiceId: string;
  invoiceNumber: string;
  brokerId: string;
  brokerName: string;
  paymentDate: string;
  amount: number;
  method: 'RTGS' | 'NEFT' | 'IMPS' | 'Cheque' | 'Cash' | 'UPI';
  transactionId?: string;
  utrNumber?: string;
  status: 'Pending' | 'Cleared' | 'Failed';
  remarks?: string;
}

export interface CommissionSummary {
  brokerId: string;
  brokerName: string;
  totalInvoices: number;
  totalCommissionAmount: number;
  totalPaid: number;
  totalOutstanding: number;
  overdueAmount: number;
  overdueCount: number;
  avgPaymentDays: number;
  onTimePaymentRate: number;
  nextPaymentDue?: {
    invoiceNumber: string;
    amount: number;
    dueDate: string;
    daysUntilDue: number;
  };
}

/**
 * Commission Service Class
 */
export class CommissionService {
  /**
   * Generate commission invoice after trade completion
   */
  static generateCommissionInvoice(
    contract: any,
    commissionConfig: CommissionConfig,
    brokerDetails: {
      brokerId: string;
      brokerName: string;
      brokerGSTIN?: string;
      brokerEmail: string;
    },
    commissionType: 'buyer' | 'seller',
    subBrokerDetails?: {
      subBrokerId: string;
      subBrokerName: string;
      subBrokerEmail: string;
      sharePercent: number; // 0-100
    }
  ): CommissionInvoice {
    const today = new Date();
    const dueDate = new Date(today);
    dueDate.setDate(dueDate.getDate() + commissionConfig.paymentTermDays);

    // Calculate commission amount
    let commissionAmount = 0;
    
    if (commissionConfig.type === 'PERCENTAGE') {
      commissionAmount = (contract.value * commissionConfig.value) / 100;
    } else if (commissionConfig.type === 'PER_BALE') {
      commissionAmount = contract.quantityBales * commissionConfig.value;
    } else {
      commissionAmount = commissionConfig.value;
    }

    // Calculate GST (18% on commission - SAC 9983)
    const gstAmount = commissionConfig.gstApplicable
      ? (commissionAmount * commissionConfig.gstRate) / 100
      : 0;

    const totalAmount = commissionAmount + gstAmount;

    // Handle sub-broker split
    let mainBrokerAmount = totalAmount;
    let subBrokerAmount = 0;
    
    if (subBrokerDetails) {
      subBrokerAmount = (totalAmount * subBrokerDetails.sharePercent) / 100;
      mainBrokerAmount = totalAmount - subBrokerAmount;
    }

    const invoice: CommissionInvoice = {
      id: `COM-${Date.now()}`,
      invoiceNumber: `COM-INV-${today.getFullYear()}-${String(Date.now()).slice(-6)}`,
      invoiceDate: today.toISOString().split('T')[0],
      dueDate: dueDate.toISOString().split('T')[0],
      
      contractId: contract.id,
      contractNo: contract.scNo,
      contractDate: contract.date,
      contractValue: contract.value,
      commodity: contract.commodityName,
      quantity: contract.quantityBales,
      
      brokerId: brokerDetails.brokerId,
      brokerName: brokerDetails.brokerName,
      brokerGSTIN: brokerDetails.brokerGSTIN,
      brokerEmail: brokerDetails.brokerEmail,
      
      commissionType,
      commissionConfig,
      commissionAmount,
      gstAmount,
      totalAmount,
      
      hasSubBroker: !!subBrokerDetails,
      subBrokerId: subBrokerDetails?.subBrokerId,
      subBrokerName: subBrokerDetails?.subBrokerName,
      subBrokerEmail: subBrokerDetails?.subBrokerEmail,
      commissionSharePercent: subBrokerDetails?.sharePercent,
      subBrokerAmount,
      mainBrokerAmount,
      
      status: 'Draft',
      paidAmount: 0,
      outstandingAmount: totalAmount,
      
      remindersSent: 0,
      
      autoGenerated: true,
      emailSent: false,
      
      createdBy: 'System',
      createdAt: today.toISOString(),
      updatedAt: today.toISOString(),
    };

    return invoice;
  }

  /**
   * Send commission invoice via email
   */
  static async sendCommissionInvoice(invoice: CommissionInvoice): Promise<boolean> {
    try {
      const emailContent = this.generateInvoiceEmail(invoice);
      
      // Send to main broker
      await this.sendEmail({
        to: invoice.brokerEmail,
        subject: `Commission Invoice ${invoice.invoiceNumber}`,
        html: emailContent,
        attachments: [
          {
            filename: `${invoice.invoiceNumber}.pdf`,
            content: this.generateInvoicePDF(invoice), // Would generate PDF
          },
        ],
      });

      // Send to sub-broker if applicable
      if (invoice.hasSubBroker && invoice.subBrokerEmail) {
        const subBrokerEmailContent = this.generateSubBrokerInvoiceEmail(invoice);
        await this.sendEmail({
          to: invoice.subBrokerEmail,
          subject: `Sub-broker Commission Invoice ${invoice.invoiceNumber}`,
          html: subBrokerEmailContent,
          attachments: [
            {
              filename: `SUB-${invoice.invoiceNumber}.pdf`,
              content: this.generateSubBrokerInvoicePDF(invoice),
            },
          ],
        });
      }

      invoice.status = 'Sent';
      invoice.sentDate = new Date().toISOString().split('T')[0];
      invoice.emailSent = true;
      invoice.nextReminderDate = this.calculateNextReminderDate(invoice.dueDate);

      console.log(`Commission invoice ${invoice.invoiceNumber} sent successfully`);
      return true;
    } catch (error) {
      console.error('Failed to send commission invoice:', error);
      return false;
    }
  }

  /**
   * Send payment reminder
   */
  static async sendPaymentReminder(
    invoice: CommissionInvoice,
    reminderType: 'gentle' | 'firm' | 'urgent'
  ): Promise<boolean> {
    try {
      const daysOverdue = this.getDaysOverdue(invoice.dueDate);
      const emailContent = this.generateReminderEmail(invoice, reminderType, daysOverdue);

      await this.sendEmail({
        to: invoice.brokerEmail,
        subject: this.getReminderSubject(invoice.invoiceNumber, reminderType, daysOverdue),
        html: emailContent,
      });

      // Also send to sub-broker if applicable
      if (invoice.hasSubBroker && invoice.subBrokerEmail) {
        await this.sendEmail({
          to: invoice.subBrokerEmail,
          subject: this.getReminderSubject(invoice.invoiceNumber, reminderType, daysOverdue),
          html: emailContent,
        });
      }

      invoice.remindersSent++;
      invoice.lastReminderDate = new Date().toISOString().split('T')[0];
      invoice.nextReminderDate = this.calculateNextReminderDate(invoice.dueDate, invoice.remindersSent);

      console.log(`Reminder ${invoice.remindersSent} sent for ${invoice.invoiceNumber}`);
      return true;
    } catch (error) {
      console.error('Failed to send reminder:', error);
      return false;
    }
  }

  /**
   * Auto-schedule reminders based on payment terms
   */
  static scheduleReminders(invoice: CommissionInvoice): {
    reminderDates: string[];
    reminderTypes: Array<'gentle' | 'firm' | 'urgent'>;
  } {
    const dueDate = new Date(invoice.dueDate);
    const reminderDates: string[] = [];
    const reminderTypes: Array<'gentle' | 'firm' | 'urgent'> = [];

    // Reminder schedule:
    // 1. 7 days before due date (gentle)
    const reminder1 = new Date(dueDate);
    reminder1.setDate(reminder1.getDate() - 7);
    reminderDates.push(reminder1.toISOString().split('T')[0]);
    reminderTypes.push('gentle');

    // 2. 1 day before due date (gentle)
    const reminder2 = new Date(dueDate);
    reminder2.setDate(reminder2.getDate() - 1);
    reminderDates.push(reminder2.toISOString().split('T')[0]);
    reminderTypes.push('gentle');

    // 3. On due date (firm)
    reminderDates.push(dueDate.toISOString().split('T')[0]);
    reminderTypes.push('firm');

    // 4. 3 days after due date (firm)
    const reminder4 = new Date(dueDate);
    reminder4.setDate(reminder4.getDate() + 3);
    reminderDates.push(reminder4.toISOString().split('T')[0]);
    reminderTypes.push('firm');

    // 5. 7 days after due date (urgent)
    const reminder5 = new Date(dueDate);
    reminder5.setDate(reminder5.getDate() + 7);
    reminderDates.push(reminder5.toISOString().split('T')[0]);
    reminderTypes.push('urgent');

    // 6. 15 days after due date (urgent + escalation)
    const reminder6 = new Date(dueDate);
    reminder6.setDate(reminder6.getDate() + 15);
    reminderDates.push(reminder6.toISOString().split('T')[0]);
    reminderTypes.push('urgent');

    return { reminderDates, reminderTypes };
  }

  /**
   * Record commission payment
   */
  static recordCommissionPayment(
    invoice: CommissionInvoice,
    payment: Partial<CommissionPayment>
  ): CommissionPayment {
    const commissionPayment: CommissionPayment = {
      id: `COMP-${Date.now()}`,
      paymentId: payment.paymentId || `PAY-${Date.now()}`,
      commissionInvoiceId: invoice.id,
      invoiceNumber: invoice.invoiceNumber,
      brokerId: invoice.brokerId,
      brokerName: invoice.brokerName,
      paymentDate: payment.paymentDate || new Date().toISOString().split('T')[0],
      amount: payment.amount || 0,
      method: payment.method || 'RTGS',
      transactionId: payment.transactionId,
      utrNumber: payment.utrNumber,
      status: 'Pending',
      remarks: payment.remarks,
    };

    // Update invoice
    invoice.paidAmount += commissionPayment.amount;
    invoice.outstandingAmount = invoice.totalAmount - invoice.paidAmount;
    
    if (invoice.outstandingAmount <= 0) {
      invoice.status = 'Paid';
      invoice.paymentDate = commissionPayment.paymentDate;
    } else if (invoice.paidAmount > 0) {
      invoice.status = 'Partially_Paid';
    }

    invoice.updatedAt = new Date().toISOString();

    return commissionPayment;
  }

  /**
   * Get commission summary for broker
   */
  static getCommissionSummary(
    brokerId: string,
    invoices: CommissionInvoice[]
  ): CommissionSummary {
    const brokerInvoices = invoices.filter(inv => inv.brokerId === brokerId);
    
    const totalInvoices = brokerInvoices.length;
    const totalCommissionAmount = brokerInvoices.reduce((sum, inv) => sum + inv.totalAmount, 0);
    const totalPaid = brokerInvoices.reduce((sum, inv) => sum + inv.paidAmount, 0);
    const totalOutstanding = brokerInvoices.reduce((sum, inv) => sum + inv.outstandingAmount, 0);
    
    const overdueInvoices = brokerInvoices.filter(inv => 
      new Date(inv.dueDate) < new Date() && inv.outstandingAmount > 0
    );
    const overdueAmount = overdueInvoices.reduce((sum, inv) => sum + inv.outstandingAmount, 0);
    const overdueCount = overdueInvoices.length;

    // Calculate average payment days
    const paidInvoices = brokerInvoices.filter(inv => inv.status === 'Paid' && inv.paymentDate);
    const avgPaymentDays = paidInvoices.length > 0
      ? paidInvoices.reduce((sum, inv) => {
          const invoiceDate = new Date(inv.invoiceDate);
          const paymentDate = new Date(inv.paymentDate!);
          const days = Math.floor((paymentDate.getTime() - invoiceDate.getTime()) / (1000 * 60 * 60 * 24));
          return sum + days;
        }, 0) / paidInvoices.length
      : 0;

    const onTimePayments = paidInvoices.filter(inv => {
      const dueDate = new Date(inv.dueDate);
      const paymentDate = new Date(inv.paymentDate!);
      return paymentDate <= dueDate;
    }).length;

    const onTimePaymentRate = paidInvoices.length > 0
      ? (onTimePayments / paidInvoices.length) * 100
      : 0;

    // Find next payment due
    const unpaidInvoices = brokerInvoices
      .filter(inv => inv.outstandingAmount > 0)
      .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());

    const nextPaymentDue = unpaidInvoices.length > 0
      ? {
          invoiceNumber: unpaidInvoices[0].invoiceNumber,
          amount: unpaidInvoices[0].outstandingAmount,
          dueDate: unpaidInvoices[0].dueDate,
          daysUntilDue: Math.floor(
            (new Date(unpaidInvoices[0].dueDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)
          ),
        }
      : undefined;

    return {
      brokerId,
      brokerName: brokerInvoices[0]?.brokerName || 'Unknown',
      totalInvoices,
      totalCommissionAmount,
      totalPaid,
      totalOutstanding,
      overdueAmount,
      overdueCount,
      avgPaymentDays,
      onTimePaymentRate,
      nextPaymentDue,
    };
  }

  /**
   * Check and send due reminders (daily cron job)
   */
  static async checkAndSendReminders(invoices: CommissionInvoice[]): Promise<number> {
    const today = new Date().toISOString().split('T')[0];
    let remindersSent = 0;

    for (const invoice of invoices) {
      if (invoice.status === 'Paid') continue;

      const schedule = this.scheduleReminders(invoice);
      const reminderIndex = schedule.reminderDates.indexOf(today);

      if (reminderIndex !== -1 && reminderIndex >= invoice.remindersSent) {
        const reminderType = schedule.reminderTypes[reminderIndex];
        const sent = await this.sendPaymentReminder(invoice, reminderType);
        if (sent) remindersSent++;
      }
    }

    console.log(`Daily reminder check: ${remindersSent} reminders sent`);
    return remindersSent;
  }

  /**
   * Private helper methods
   */
  private static getDaysOverdue(dueDate: string): number {
    const due = new Date(dueDate);
    const today = new Date();
    return Math.max(0, Math.floor((today.getTime() - due.getTime()) / (1000 * 60 * 60 * 24)));
  }

  private static calculateNextReminderDate(dueDate: string, remindersSent: number = 0): string {
    const schedule = this.scheduleReminders({ dueDate } as CommissionInvoice);
    const nextIndex = remindersSent;
    
    if (nextIndex < schedule.reminderDates.length) {
      return schedule.reminderDates[nextIndex];
    }
    
    // If all scheduled reminders sent, send weekly
    const nextReminder = new Date();
    nextReminder.setDate(nextReminder.getDate() + 7);
    return nextReminder.toISOString().split('T')[0];
  }

  private static getReminderSubject(
    invoiceNumber: string,
    reminderType: 'gentle' | 'firm' | 'urgent',
    daysOverdue: number
  ): string {
    if (reminderType === 'gentle') {
      return `Upcoming Payment: Commission Invoice ${invoiceNumber}`;
    } else if (reminderType === 'firm') {
      return `Payment Due: Commission Invoice ${invoiceNumber}`;
    } else {
      return `URGENT: Overdue Payment (${daysOverdue} days) - Invoice ${invoiceNumber}`;
    }
  }

  private static generateInvoiceEmail(invoice: CommissionInvoice): string {
    return `
      <h2>Commission Invoice</h2>
      <p>Dear ${invoice.brokerName},</p>
      <p>Please find attached commission invoice for contract ${invoice.contractNo}.</p>
      
      <table>
        <tr><td>Invoice Number:</td><td>${invoice.invoiceNumber}</td></tr>
        <tr><td>Invoice Date:</td><td>${invoice.invoiceDate}</td></tr>
        <tr><td>Due Date:</td><td>${invoice.dueDate}</td></tr>
        <tr><td>Contract:</td><td>${invoice.contractNo}</td></tr>
        <tr><td>Commission Amount:</td><td>₹${invoice.commissionAmount.toLocaleString()}</td></tr>
        <tr><td>GST (18%):</td><td>₹${invoice.gstAmount.toLocaleString()}</td></tr>
        <tr><td><strong>Total Amount:</strong></td><td><strong>₹${invoice.totalAmount.toLocaleString()}</strong></td></tr>
      </table>
      
      <p>Payment is due within ${invoice.commissionConfig.paymentTermDays} days from invoice date.</p>
      <p>Thank you for your business!</p>
    `;
  }

  private static generateSubBrokerInvoiceEmail(invoice: CommissionInvoice): string {
    return `
      <h2>Sub-broker Commission Invoice</h2>
      <p>Dear ${invoice.subBrokerName},</p>
      <p>Please find attached your share of commission for contract ${invoice.contractNo}.</p>
      
      <table>
        <tr><td>Invoice Number:</td><td>${invoice.invoiceNumber}</td></tr>
        <tr><td>Your Share:</td><td>${invoice.commissionSharePercent}%</td></tr>
        <tr><td><strong>Your Amount:</strong></td><td><strong>₹${invoice.subBrokerAmount?.toLocaleString()}</strong></td></tr>
      </table>
    `;
  }

  private static generateReminderEmail(
    invoice: CommissionInvoice,
    reminderType: 'gentle' | 'firm' | 'urgent',
    daysOverdue: number
  ): string {
    if (reminderType === 'gentle') {
      return `
        <p>Dear ${invoice.brokerName},</p>
        <p>This is a friendly reminder that commission payment for invoice ${invoice.invoiceNumber} is due on ${invoice.dueDate}.</p>
        <p>Amount: ₹${invoice.outstandingAmount.toLocaleString()}</p>
        <p>Thank you!</p>
      `;
    } else if (reminderType === 'firm') {
      return `
        <p>Dear ${invoice.brokerName},</p>
        <p>Payment for commission invoice ${invoice.invoiceNumber} is now due.</p>
        <p>Amount: ₹${invoice.outstandingAmount.toLocaleString()}</p>
        <p>Please make payment at the earliest.</p>
      `;
    } else {
      return `
        <p>Dear ${invoice.brokerName},</p>
        <p><strong>URGENT:</strong> Payment for commission invoice ${invoice.invoiceNumber} is overdue by ${daysOverdue} days.</p>
        <p>Outstanding Amount: ₹${invoice.outstandingAmount.toLocaleString()}</p>
        <p>Please make immediate payment to avoid further action.</p>
      `;
    }
  }

  private static generateInvoicePDF(invoice: CommissionInvoice): Buffer {
    // Would generate actual PDF using library like pdfkit or puppeteer
    return Buffer.from('PDF content');
  }

  private static generateSubBrokerInvoicePDF(invoice: CommissionInvoice): Buffer {
    return Buffer.from('Sub-broker PDF content');
  }

  private static async sendEmail(options: {
    to: string;
    subject: string;
    html: string;
    attachments?: any[];
  }): Promise<void> {
    // Would use actual email service (SendGrid, SES, SMTP)
    console.log(`Email sent to ${options.to}: ${options.subject}`);
  }
}

export default CommissionService;
